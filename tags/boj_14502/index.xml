<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BOJ_14502 on Meantint&#39;s BLog</title>
    <link>https://meantint.github.io/tags/boj_14502/</link>
    <description>Recent content in BOJ_14502 on Meantint&#39;s BLog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Thu, 23 Jul 2020 01:29:07 +0900</lastBuildDate>
    
	<atom:link href="https://meantint.github.io/tags/boj_14502/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>BOJ 14502 - 연구소</title>
      <link>https://meantint.github.io/post/2020/07/boj_14502/</link>
      <pubDate>Thu, 23 Jul 2020 01:29:07 +0900</pubDate>
      
      <guid>https://meantint.github.io/post/2020/07/boj_14502/</guid>
      <description>[BOJ_14502 - 연구소]
 Brute Force로 해결하였다. 문제에서 제시된 2차원 배열의 범위가 작아서 시간 복잡도가 꽤 여유롭다.
풀이   벽을 3칸 치는 작업을 완전탐색을 이용하여 한다.
  벽을 3칸 쳤다면 바이러스를 벽이 없는 사방으로 퍼뜨리는 virus()를 호출한다.
  호출한 후 안전영역의 개수를 구한 후, 기존에 저장되어 있는 값과 비교하여 갱신해준다.
  Code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int answer = -1; int safeArea; int n, m; void virus(int i, int j, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; vec) { if (i &amp;lt; 0 || i &amp;gt;= n || j &amp;lt; 0 || j &amp;gt;= m) return; if (vec[i][j] !</description>
    </item>
    
  </channel>
</rss>