---
title: "프로그래머스 - 단속카메라"
date: 2020-08-15T08:50:24+09:00
categories:
- Programmers
tags:
- Programmers
- 프로그래머스
- 단속카메라
draft: false
---

[[프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/42884) - [단속카메라](https://programmers.co.kr/learn/courses/30/lessons/42884)]

&nbsp;그리디(Greedy)를 이용해 풀었다. 방법을 못찾아서 꽤 오랫동안 헤맸다.

My Programmers Code : [https://github.com/Meantint/Programmers](https://github.com/Meantint/Programmers)

<hr>

# 풀이

- 나가는 순서대로 정렬한 `routes`, 카메라를 만났는지의 여부를 확인하는 `isCheck`를 만든다.

- `routes[idx][0]`을 계산하기 위한 `idx`를 선언한다.

- `i`번째 자동차가 카메라에서 벗어나기 직전의 시점인 `routes[i][1]`에서 찍히는 자동차(`routes[idx][0]` ~ `routes[idx][1]`)가 있는지 확인하고 있으면 `++idx`, 없으면 `continue`를 진행한다.

	- 나가는 순서대로 정렬을 했는데 `++idx`를 하면서 탐색하는 이유를 생각해내는 것이 어려웠다. 나가는 순서대로 정렬을 했다고 들어오는게 정렬이 된 것이 아니기 때문이다. 결론을 말하자면 `i`에서 찾을 수 있는 차량들을 그 순간에 모두 찾지 않아도 답을 구할 수 있다.
	 
	- 예를 들어 `routes[0] = (0, 5)`, `routes[1] = (6, 10)`, `routes[2] = (2, 15)`라고 하자. 처음에 `routes[0][1]`은 `routes[2][0]`과 `routes[2][1]`에는 속하지만 `routes[1][0]`과 `routes[1][1]`에는 속하지 않는다.
	 
	- 그러면 내가 작성한 코드는 `idx`를 순차적으로 늘리면서 찾기 때문에 `idx = 2`인 경우를 검출을 하지 못하는 것이 아니냐고 생각할 수 있다. 아니다.

	- 정렬을 한 경우 `routes[1][1]`은 무조건 `routes[2][1]` 보다 작다. 그런데 예제에서 `routes[1][0]`이 `routes[2][0]` 보다 크기 때문에 `routes[2][0]`과 `routes[2][1]` 사이에는 항상 routes[1][1]이 있기 때문에 `i = 1`일 때 `idx = 2`가 검출되므로 굳이 `i = 0`일 때 `idx = 2`인 경우를 찾지 않아도 문제를 해결할 수 있다.

<hr>

# Code

```c++
#include <bits/stdc++.h>

using namespace std;

bool cmp(vector<int> v1, vector<int> v2)
{
    return v1[1] < v2[1];
}

int solution(vector<vector<int>> routes)
{
    int answer = 0;

    vector<bool> isCheck(routes.size(), false);
    sort(routes.begin(), routes.end(), cmp);

    int idx = 0;
    int size = routes.size();
    for (int i = 0; i < size; ++i) {
        if (!isCheck[i]) {
            isCheck[i] = true;
            ++answer;

            for (; idx < size; ++idx) {
                if (isCheck[idx]) {
                    continue;
                }
                if (routes[i][1] >= routes[idx][0] && routes[i][1] <= routes[idx][1]) { // 자른 부분이 다음 경로 안에 포함된다면
                    isCheck[idx] = true;
                    continue;
                }
                break;
            }
        }
    }

    return answer;
}

int main()
{
    cout << solution({ { -20, 15 }, { -14, -5 }, { -18, -13 }, { -5, -3 } }) << '\n';

    return 0;
}
```

<hr>