---
title: "프로그래머스 - 무지의 먹방 라이브"
date: 2020-09-02T02:14:18+09:00
categories:
- Programmers
tags:
- Programmers
- 프로그래머스
- 무지의 먹방 라이브
- 이분탐색
- Binary Search
draft: false
# toc: false
# images:
---

[[프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/42891) - [무지의 먹방 라이브](https://programmers.co.kr/learn/courses/30/lessons/42891)]

&nbsp;카카오 블라인드 채용 대비를 하면서 풀었던 문제. 꽤 잘 풀렸다. 풀고 나서 다른 사람들의 풀이를 봤는데 대부분 우선순위큐를 이용하여 풀었다. 탐색하는 순서의 차이(`Binary Search` vs `min Heap`)를 제외한 기본적인 틀은 같은 것 같다.

<hr>

# 풀이

- 이 문제는 `k + 1`번째 먹을 음식의 번호를 물어본다고 할 수 있다.

- `food_times`의 총합 `test`가 `k + 1`보다 작으면 섭취해야 할 음식이 없으므로 -1을 리턴한다.

- `start = 1`, `end = k`, `mid = (start + end) / 2`로 설정한다. 

- 모든 음식을 `mid`번 먹었을 때(`food_times[i]`의 값이 `mid`보다 작다면 `food_times[i]`번 먹음) 걸린 시간 `sum`이
 
  1. `k`보다 작거나 같을 때
   
     - `save`에 현재 `mid` 값을 저장하고 `save_k`에 `k - sum`을 저장한다.

     - `start = mid + 1`
 
  2. `k`보다 클 때

     - `end = mid - 1`

- 위의 과정을 반복하고 while문을 빠져나오면 `sum <= k`을 만족하는 `mid`의 최대값이 `save`에 저장되어 있다.

- for문을 실행하여 `food_times[i] > save`이고

  1. `save_k == 0`이라면

	 - `i`가 `k + 1`번째 먹을 음식이기 때문에 `i + 1`(index보다 번호가 1만큼 크기 떄문에, `index[0] = 1번`)을 반환한다.
  
  1. `save_k > 0`이라면

	 - 음식을 `k`번 먹지 않았기 때문에(문제는 `k + 1`번째 먹을 음식의 번호를 물어본다고 볼 수 있다.) `--save_k` 해준다.

<hr>

# Code
```C++
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int solution(vector<int> food_times, long long k)
{
    int answer = 0;

    long long test = 0;
    int foodSize = food_times.size();
    for (int i = 0; i < foodSize; ++i) {
        test += (long long)food_times[i];
    }
    if (test < k + 1) {
        return -1;
    }

    long long start, end, mid;
    start = 1;
    end = k;

    long long save = 0;
    long long save_k = k;
    while (start <= end) {
        long long sum = 0;
        mid = (start + end) / 2;
        vector<int> cp = food_times;
        int size = food_times.size();
        for (int i = 0; i < size; ++i) {
            if (mid > cp[i]) {
                sum += (long long)cp[i];
                cp[i] = 0;
            }
            else {
                sum += (long long)mid;
                cp[i] -= mid;
            }
        }
        if (sum > k) {
            end = mid - 1;
        }
        else {  // sum <= k
            save = mid;
            save_k = k - sum;
            start = mid + 1;
        }
    }
    // cout << save << '\n';
    for (int i = 0; i < foodSize; ++i) {
        if (food_times[i] > save) {
            if (save_k == 0) {
                return i + 1;
            }
            else {
                --save_k;
            }
        }
    }

    return answer;
}

int main()
{
    cout << solution({3, 1, 2}, 5) << '\n';
    cout << solution({3, 1, 2}, 7) << '\n';
    cout << solution({7, 4, 10, 7}, 25) << '\n';
    cout << solution({7, 4, 10, 7}, 28) << '\n';
    cout << solution({1, 1, 1, 1, 1, 1}, 1) << '\n';

    return 0;
}
```

<hr>